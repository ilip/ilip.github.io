{"pages":[],"posts":[{"title":"Angurlar build issues record","text":"BackgroundDuring development of angular, I run into a lot of problems. Here I will record some, so I can recall and solve them in later times. Multi modules issue More than one module matches. Use the skip-import option to skip importing the component into the closest module or use the module option to specify a module. Specify the module using the –module parameter. For example, if the main module is app.module.ts, run this: ng g c new-component --module app Or if you are in an other directory then ng g c component-name --module ../ Also if user other framework scaffold, ng g ng-zorro-antd:form-register register --module ../","link":"/2020/07/28/angular-build-issue-record/"},{"title":"angular 持续集成部署到Azure app service","text":"背景最近一直在做 .net core项目的CICD，使用的是Jenkins平台，突然想到以前注册的Azure上还有一个subscription，然后记得以前写过一个angular应用，突发奇想，是否可以使用Azure来持续集成部署angular应用，如果成功的话，以后可以方便地使用angular来构建web前端应用。 环境 Angular Azure DevOps 需要注册账号 Azure App Service 需要注册账号 部署过程Angular安装nodejs安装angular clinpm install -g @angular/cli使用angular cli 新建app 123ng new my-appcd my-appng build --prod 上述步骤后，我们可以在 my-app/dist 目录下获得编译好的应用。因为我使用的是以前已经写好的angular app，直接运行build命令获得最终需要部署的目录。默认angular项目在IIS上直接部署后，访问异常。同样道理，dist目录直接部署到Azure App service上，访问也是异常的，这里我们需要做如下改进。具体原因可以参考: Angular官网解释在目录 my-app/src 下新建文件 web.config 内容如下： 1234567891011121314151617181920212223&lt;configuration&gt; &lt;system.webServer&gt; &lt;staticContent&gt; &lt;mimeMap fileExtension=&quot;.json&quot; mimeType=&quot;application/json&quot; /&gt; &lt;remove fileExtension=&quot;.woff&quot;/&gt; &lt;mimeMap fileExtension=&quot;.woff&quot; mimeType=&quot;application/font-woff&quot; /&gt; &lt;mimeMap fileExtension=&quot;.woff2&quot; mimeType=&quot;font/woff2&quot; /&gt; &lt;/staticContent&gt; &lt;rewrite&gt; &lt;rules&gt; &lt;rule name=&quot;Angular&quot; stopProcessing=&quot;true&quot;&gt; &lt;match url=&quot;.*&quot; /&gt; &lt;conditions logicalGrouping=&quot;MatchAll&quot;&gt; &lt;add input=&quot;{REQUEST_FILENAME}&quot; matchType=&quot;IsFile&quot; negate=&quot;true&quot; /&gt; &lt;add input=&quot;{REQUEST_FILENAME}&quot; matchType=&quot;IsDirectory&quot; negate=&quot;true&quot; /&gt; &lt;/conditions&gt; &lt;action type=&quot;Rewrite&quot; url=&quot;/&quot; /&gt; &lt;/rule&gt; &lt;/rules&gt; &lt;/rewrite&gt; &lt;/system.webServer&gt;&lt;/configuration&gt; 上述内容中 rewrite 节点作用，angular官网已经给出解释。对于staticContent 节点，主要解决angular应用调用 .json / .woff / .woff2 资源时提示404问题。添加完 web.config 文件后，我们还需要让angular在编译时识别它，我们需要修改文件 my-app/.angular-cli.json修改内容如下所示,将 web.config 文件名加入其中 1234567891011121314151617{ &quot;$schema&quot;: &quot;./node_modules/@angular/cli/lib/config/schema.json&quot;, &quot;project&quot;: { &quot;name&quot;: &quot;my-app&quot; }, &quot;apps&quot;: [ { &quot;root&quot;: &quot;src&quot;, &quot;outDir&quot;: &quot;dist&quot;, &quot;assets&quot;: [ &quot;assets&quot;, &quot;favicon.ico&quot;, &quot;web.config&quot; ], . . . Azure App Service登录Azure App Service 新建一个App service Azure DevOps我们将angular应用源码上传到Azure DevOps或者是github上，以便接下来使用Azure DevOps的pipeline，完成代码的编译和部署。这里不多做演示。下面使用我已经上传到Azure DevOps的angular应用做演示。点击项目 cloudapp-Pipelines-Builds-New pipeline 第一步 Connect 选择代码来源，这里我选择 Azure Repos Git 第二步 Select 选择具体的repository 第三步 Configure 选择 node.js 第四步 Review, Azure Pipeline 会为我们的工程新建一个文件 azure-pipelines.yml 我们可以使用右侧Tasks,快捷地添加pipeline，这里给出我的配置 12345678910111213141516171819202122232425262728293031323334353637383940# Node.js# Build a general Node.js project with npm.# Add steps that analyze code, save build artifacts, deploy, and more:# https://docs.microsoft.com/azure/devops/pipelines/languages/javascripttrigger:- masterpool: vmImage: 'ubuntu-latest'steps:- task: NodeTool@0 inputs: versionSpec: '10.x' displayName: 'Install Node.js'- task: CmdLine@2 inputs: script: 'npm install @angular/cli -g' displayName: 'Install angular cli'- task: CmdLine@2 inputs: script: 'npm install' displayName: 'Install dependencies'- task: CmdLine@2 inputs: script: 'ng build -prod' displayName: 'build angular app'- task: AzureRmWebAppDeployment@4 inputs: ConnectionType: 'AzureRM' azureSubscription: '这里输入自己的subscription' appType: 'webApp' WebAppName: 'cloudappd' packageForLinux: 'dist/' 最后点击 Save and Run 完成应用的部署 部署结果如果一切顺利的话，我们可以到 Azure DevOps cloudapp-Pipeline-Builds中看到基于刚才写的pipeline脚本build的结果。同时我们可以在Azure App Service 的活动日志中看到Deploy结果。 项目效果查看确认上述部署结果显示正常后，我们可以访问 https://cloudappd.azurewebsites.net 来查看angular应用。","link":"/2019/09/21/angular-deploy-to-azure-web-app/"},{"title":"some asp.net core issues","text":"背景asp.net core开发过程中，遇到的一些问题 ASP.NET Core DI 手动获取注入对象 方案一： （有时会获取不到） 1234var services = new ServiceCollection();var provider = services.BuildServiceProvider();var _valueService = provider.GetService&lt;IValueService&gt;(); 方案二： 1234567891011121314151617public void Configure(IApplicationBuilder app){ ServiceLocator.Instance = app.ApplicationServices;}public static class ServiceLocator{ public static IServiceProvider Instance { get; set; }}public void SomeRandomMethod(){ var valueService = ServiceLocator.Instance.GetService&lt;IValueService&gt;(); // Do something with service} 补充：需要注意的是，使用ServiceLocator.Instance.GetService();，只能获取AddTransient和AddSingleton注入的对象，而不能获取AddScoped（请求生命周期内唯一）注入的对象，不是不能获取，而是获取的和构造函数获取的不是相同对象，也就是说获取的对象没有共享，使用场景比如IUnitOfWork。 IHttpContextAccessor接口在Microsoft.AspNetCore.Http.AbstractionsNuget 程序包下。 1234567891011121314using Microsoft.AspNetCore.Http;using Microsoft.Extensions.DependencyInjection;namespace Sample.Domain{ public class SampleDomainService : IDomainService { private IUnitOfWork _unitOfWork; public SampleDomainService(IHttpContextAccessor httpContextAccessor) { _unitOfWork = httpContextAccessor.HttpContext.RequestServices.GetService&lt;IUnitOfWork&gt;(); } } VS new scaffolded item run into errorreason：the scaffolded install latest nuget Microsoft.VisualStudio.Web.CodeGeneration.Design, but your scaffolded project use old nuget dependency. So you should update your dependencied to latest version","link":"/2020/07/28/asp.net-core-issue-record/"},{"title":"azure pipelines使用小札","text":"背景最近微服务项目不断推进，后期阶段，需要实现CICD。这里就Azure Pipelines的使用做点小结。 Azure Pipelines这里给出官网文档 通用技巧123456789101112131415161718192021trigger: - masterstages: - stage: BuildStage displayName: 'build library on cross planform' jobs: - job: WindowsJob displayName: 'publish physical material library for windows' variables: publishVersion: 0.0.4 strategy: matrix: windows: imageName: 'windows-2019' pkgName: 'windows' linux: imageName: 'ubuntu-18.04' pkgName: 'linux' pool: vmImage: $(imageName) PublishPublish build artifacts12345- task: PublishBuildArtifacts@1 inputs: PathtoPublish: './x64' ArtifactName: 'testbuildartifacts' publishLocation: 'Container' 我们可以在pipeline结束后，找到对应的pipline中找到打包好的artifact 123456789- task: UniversalPackages@0 inputs: command: 'publish' publishDirectory: './x64' feedsToUsePublish: 'internal' vstsFeedPublish: '******-ebe6-4c54-a09f-29882637dbde/2e386319-f0b8-4690-afa7-********' vstsFeedPackagePublish: 'testuniversalpackage' versionOption: 'patch' packagePublishDescription: 'just test for universal package' 我们可以在Azure Devops的Artifacts对应的Feed中找到打包好的UniversalPackages 123456- task: NuGetCommand@2 inputs: command: 'push' packagesToPush: './copysofiles.nupkg' nuGetFeedType: 'internal' publishVstsFeed: '*****-ebe6-4c54-a09f-29882637dbde/2e386319-f0b8-4690-afa7-*****' 我们可以在Azure Devops的Artifacts对应的Feed中找到打包好的nuget包","link":"/2020/08/17/azure-piplines/"},{"title":"C++跨平台编译小札","text":"背景最近项目上需要将已有的VS项目迁移到dockers中运行，然后想方设法将C++代码改成跨平台编译，其中遇到了各种问题。 使用到的Cmake Settings12set(VCPKG_ROOT &quot;${CMAKE_SOURCE_DIR}/vcpkg/scripts/buildsystems/vcpkg.cmake&quot; CACHE PATH &quot;&quot;)set(CMAKE_TOOLCHAIN_FILE ${VCPKG_ROOT}) set vcpkg path to CMakeList.txt set (CMAKE_SHARED_LINKER_FLAGS &quot;-Wl,--unresolved-symbols=ignore-in-shared-libs -shared -Wl,-rpath,protocol_so:lib64:libwifi&quot;) 编译的动态链接库的时候最好加上 –unresolved-symbols=ignore-in-shared-libs 或者 –no-undefined 来检查一下link问题。参数可以使用–undefined symbols 和 –no-allow-shlib-undefined 参数的作用范围不一样而已，–undefined symbols 针对常规object文件，–no-allow-shlib-undefined针对的是符号在外部的未定义的shared object里面。–unresolved-symbols和–undefined symbols 作用差不多，不过更具体一些。 set(CMAKE_CXX_FLAGS&quot;-lboost_system -lboost_timer -lboost_chrono -lrt -lboost_thread -lboost_thread -lgsl -lgslcblas&quot;)不建议使用 CMAKE_CXX_FLAGS 链接库，而应该使用Cmake中语法 target_link_libraries，这里只是表达下它的可能用法 set (CMAKE_CXX_STANDARD 11)设置C++语法版本 Cmake 编译中遇到链接问题，注意引用的静态库（.a）所依赖的静态库要也一起引入进来 Cmake 编译中遇到链接问题，注意调整下target_link_libraries 中各个依赖库的位置顺序 Linux下分析问题方法nm libtest.so -u | grep boost 用 nm -Du BINARY 只会显示使用到但未定义的 symbol 12345ldd -r libtest.sold libtest.sofile libpathplan.so c++filt _ZN5boost10filesystem6detail13dir_itr_closeERPvS3_ 使用 c++filt symbol 定位错误在那个C++文件中","link":"/2020/08/21/crossplatform-build/"},{"title":"最早的记忆片段","text":"前记夜已经很深了，无聊的我没有任何睡意。看着电视剧《三十而已》，其中的一个片段-钟晓芹开始写心情博客，突然想起，很久没有更新博客了。 一开始的设想，这个博客主要用来写一些技术相关的东西，只是渐渐感觉到，自己做事情没有很从一而终，没有把最一开始的想法坚持下来，但，不能就比罢了，总得重拾些什么吧。 题外话和我接触久的人，都会说我很想讲话，有些啰嗦，一开始我不在意这些说法。但是很多个人这么说了，我心中难免开始揣摩起来。 我吧，生性不知道怎么样，到现在我自己也没想透，但，应该算是一个藏不住心事的人吧。或者是懒，懒得思考，懒得注意细节，等等。说的话，几乎是随着心意走，越是熟悉的人，表现的越是明显，最后弄的大家很难堪，而我自己又觉得很委屈。 还有一点，可能是生活或者工作的原因，能够放肆畅谈的机会不是特别多，内心一直积蕴着没能及时说出的话语。然后，在某个时间点就喷发而出，这样，大家可能觉得我很想讲话，很啰嗦。其实我觉得这不能体现出我的性格，而是，我生理的一个需求。 为啥要说上面的内容呢？我在为我下面写文章啰嗦，而提前打的一个招呼。 入题这次我想写的是，我目前能想起的最久远的记忆。在脑海里翻了半天，都是些零碎的记忆。模糊的觉得最远的记忆是幼儿园时，是用围巾当作跳绳，然后绊倒卡出鼻血的事。其实，很早我就在想回忆的事情，一直想把时间点往前提，但，这个点好象是最远的了。","link":"/2020/07/28/deepest-in-memory/"},{"title":"deploy asp.net core app service to VM","text":"背景部署 aps.net core web service时，遇到的各种问题记录 IdentityServer4 run in production environmentfor me, I choose the following style: 1234567&quot;IdentityServer&quot;: { &quot;Key&quot;: { &quot;Type&quot;: &quot;File&quot;, &quot;FilePath&quot;: &quot;C:\\cert.pfx&quot;, &quot;Password&quot;: &quot;password123&quot; } } for more detail, Following this how to generate .pfx file follow the steps deploy web service in https modefollow the steps Nginx setting for VM12345678910111213141516171819202122232425262728293031server { listen 80; listen [::]:80; server_name ilip.eastus.cloudapp.azure.com; root /var/www/ilip.eastus.cloudapp.azure.com; index index.html; location / { try_files $uri $uri/ =404; }}server { listen 443 ssl; server_name ilip.eastus.cloudapp.azure.com; ssl_certificate /etc/ssl/ilip.eastus.cloudapp.azure.com/cert.pem; ssl_certificate_key /etc/ssl/ilip.eastus.cloudapp.azure.com/key.pem; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers HIGH:!aNULL:!MD5; root /var/www/ilip.eastus.cloudapp.azure.com; index index.html; location / { try_files $uri $uri/ =404; }} https certification registeruse root permission run follow command 12345678910curl https://get.acme.sh | shacme.sh --issue --nginx -d ilip.eastus.cloudapp.azure.comacme.sh --install-cert -d ilip.eastus.cloudapp.azure.com \\--key-file /etc/ssl/ilip.eastus.cloudapp.azure.com/key.pem \\--fullchain-file /etc/ssl/ilip.eastus.cloudapp.azure.com/cert.pem \\--reloadcmd &quot;service nginx force-reload&quot;acme.sh --cron -f dotnet run as service in ubuntu1sudo vi /etc/systemd/system/ilipapp.service 1234567891011121314151617181920[Unit]Description=ilip's .NET Web API App running on Ubuntu[Service]WorkingDirectory=/var/www/ilip.eastus.cloudapp.azure.comExecStart=/usr/bin/dotnet /var/www/ilip.eastus.cloudapp.azure.com/HelloWebAspnetcore.dllRestart=always# Restart service after 10 seconds if the dotnet service crashes:RestartSec=10KillSignal=SIGINTSyslogIdentifier=dotnet-exampleUser=ilipEnvironment=ASPNETCORE_ENVIRONMENT=ProductionEnvironment=DOTNET_PRINT_TELEMETRY_MESSAGE=falseEnvironment=ConnectionStrings__DefaultConnection=hiiamconnectstring# The default value is 90 seconds for most distributions.TimeoutStopSec=90[Install]WantedBy=multi-user.target 123456sudo systemctl daemon-reloadsudo systemctl enable ilip.servicesudo systemctl start ilip.servicesudo systemctl status ilip.servicesudo systemctl stop ilip.service view logssudo journalctl -fu ilip.service security nginx conf setting example proxy.conf 1234567891011proxy_redirect off;proxy_set_header Host $host;proxy_set_header X-Real-IP $remote_addr;proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;proxy_set_header X-Forwarded-Proto $scheme;client_max_body_size 10m;client_body_buffer_size 128k;proxy_connect_timeout 90;proxy_send_timeout 90;proxy_read_timeout 90;proxy_buffers 32 4k; nginx.conf add the following settings 123456789101112131415http { include /etc/nginx/proxy.conf; limit_req_zone $binary_remote_addr zone=one:10m rate=5r/s; server_tokens off; client_body_timeout 10; client_header_timeout 10; send_timeout 10; upstream ilipapp{ server localhost:5000; } ...} 1234567891011121314151617181920212223242526272829303132server { listen *:80; add_header Strict-Transport-Security max-age=15768000; return 301 https://$host$request_uri;}server { listen *:443 ssl; server_name ilip.eastus.cloudapp.azure.com; ssl_certificate /etc/ssl/ilip.eastus.cloudapp.azure.com/cert.pem; ssl_certificate_key /etc/ssl/ilip.eastus.cloudapp.azure.com/key.pem; ssl_protocols TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; ssl_ciphers &quot;EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH&quot;; ssl_ecdh_curve secp384r1; ssl_session_cache shared:SSL:10m; ssl_session_tickets off; ssl_stapling on; #ensure your cert is capable ssl_stapling_verify on; #ensure your cert is capable add_header Strict-Transport-Security &quot;max-age=63072000; includeSubdomains; preload&quot;; add_header X-Frame-Options DENY; add_header X-Content-Type-Options nosniff; #Redirects all traffic location / { proxy_pass http://ilipapp; limit_req zone=one burst=10 nodelay; }} Install Mysql in Ubuntu 18.0412345sudo apt updatesudo apt install mysql-serversudo mysql_secure_installation follow the settings 需要设置 mysql 数据库支持外部或者远程访问，则需要把绑定 IP 地址改为 0.0.0.0，或者不写IP地址。因此编辑配置文件： $ sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf修改绑定地址为 0.0.0.0。原来默认绑定 127.0.0.1 注释掉。 12bind-address = 0.0.0.0# bind-address = 127.0.0.1 允许root用户远程登陆 GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'password' WITH GRANT OPTION; 1234##1 创建数据库ilipCREATE DATABASE ilipdb;##2 创建用户ilip密码 并允许ilip用户可以从任意机器上登入mysql的weixx数据库GRANT ALL PRIVILEGES ON ilip.* TO ilipdb@&quot;%&quot; IDENTIFIED BY &quot;password&quot;;","link":"/2020/10/17/deploy-asp-net-app-to-vm/"},{"title":"禁用系统drag full windows属性，实现拖拽窗口虚线预览功能","text":"背景最近项目上遇到列表控件刷新问题，由于大量数据条目需要显示，在拖拽控件窗口时刷新性能十分缓慢。考虑到项目历史原因，更换整个刷新控件不现实，于是开始了漫漫性能优化之路。在这工程中遇到一个奇怪的问题，在不同测试机上，同一个软件测试版本，对于浮动窗口大小拖拽，有的会显示虚线框预览，有的会实时刷新，导致UI显示十分卡顿，十分影响用户体验。 方案在网上查询了不少方案，其中较为靠谱的方案是取消设置windows系统Show window contents while dragging属性，使得系统采取虚线框预览模式。当然这个设置是影响整个windows系统所有软件的，其中利弊需自己取舍。 方案一设置路径为-&gt; This PC -&gt; right click Properties -&gt; Advanced -&gt; Performance Settings -&gt; Visual Effects -&gt; Show window contents while draging这个修改是实时生效的，修改完后，所有window程序窗口的拖拽都会显示虚线框预览，松开鼠标后才会刷新真正内容。 方案二修改注册表值，但该方案需注销后才能生效。将以下代码保存为 Show_window_outline_while_dragging.reg 123456Windows Registry Editor Version 5.00; Created by: ilip[HKEY_CURRENT_USER\\Control Panel\\Desktop]&quot;DragFullWindows&quot;=&quot;0&quot; 修改代码中&quot;DragFullWindows&quot;=&quot;0&quot; 为 &quot;DragFullWindows&quot;=&quot;1&quot; 即可在拖拽窗口时，实时刷新窗口内容 方案三在项目中加入以下代码，可以直接需改系统DragFullWindows属性，在项目程序退出后可以还原为用户以前设置 1234567891011121314151617181920212223#include &lt;windows.h&gt;#include &lt;tchar.h&gt;#include &lt;cstdio&gt;#pragma comment(lib, &quot;user32.lib&quot;) int _tmain(int argc, _TCHAR* argv[]){ BOOL enabled; SystemParametersInfo(SPI_GETDRAGFULLWINDOWS, NULL, &amp;enabled, 0); printf(&quot;Current 'dragfullwindow' option status: %d\\n&quot;, enabled); if (!enabled) { SystemParametersInfo(SPI_SETDRAGFULLWINDOWS, TRUE, NULL, SPIF_UPDATEINIFILE | SPIF_SENDCHANGE); } return 0;}","link":"/2019/09/18/disable-show-window-contents-while-dragging/"},{"title":"Hello Markdown","text":"欢迎来到 ilip主页 markdown 常见格式 这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题这是倾斜的文字 这是加粗的文字 这是斜体加粗的文字 这是加删除线的文字 这是引用的内容 这是引用的内容 这是引用的文字 分割线1 分割线2 分割线3 分割线4 列表内容 列表内容 列表内容 注意：- + * 跟内容之间都要有一个空格 列表内容 列表内容 列表内容 注意：序号跟内容之间要有空格 姓名 技能 排行 刘备 哭 大哥 关羽 打 二哥 张飞 骂 三弟 第二行分割表头和内容。 -有一个就行，为了对齐，多加了几个文字默认居左 -两边加：表示文字居中 -右边加：表示文字居右 注：原生的语法两边都要用 | 包起来。此处省略 单行代码 create database hero; 12345多行代码...function fun(){ echo &quot;这是一句非常牛逼的代码&quot;;}fun(); 流程图 123456789st=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op","link":"/2019/09/07/markdown-usage/"},{"title":"使用nuget包管理项目依赖","text":"背景最近一直在做应用程序跨平台相关的任务，使用了.net core实现了微服务框架，然后核心C++业务实现了跨平台，产生了可被调用的.so文件。最终，在程序运行的时候，需要将.so文件copy到运行路径。一开始为了调试工作方便，直接在Dockfile文件中，使用copy命令，来copy .so文件，随着开发的升入，需要将这一过程自动化。考虑到，目前使用的Devops为Azure Devops，而且是.net core项目，最终决定使用Nuget工具来实现这一目的。 Nuget直接给出官网文档 用到的文件 copysofiles.tagets 12345678910&lt;Project xmlns=&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;&gt; &lt;ItemGroup&gt; &lt;None Include=&quot;$(MSBuildThisFileDirectory)..\\linux\\libcopysofile1.so&quot;&gt; &lt;CopyToOutputDirectory&gt;Always&lt;/CopyToOutputDirectory&gt; &lt;/None&gt; &lt;None Include=&quot;$(MSBuildThisFileDirectory)..\\linux\\libcopysofile2.so&quot;&gt; &lt;CopyToOutputDirectory&gt;Always&lt;/CopyToOutputDirectory&gt; &lt;/None&gt; &lt;/ItemGroup&gt;&lt;/Project&gt; copysofiles.nuspc 123456789101112131415161718&lt;?xml version=&quot;1.0&quot;?&gt;&lt;package xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt; &lt;metadata xmlns=&quot;http://schemas.microsoft.com/packaging/2010/07/nuspec.xsd&quot;&gt; &lt;id&gt;copysofiles&lt;/id&gt; &lt;title&gt;copysofiles&lt;/title&gt; &lt;version&gt;0.0.0&lt;/version&gt; &lt;authors&gt;ilip&lt;/authors&gt; &lt;requireLicenseAcceptance&gt;false&lt;/requireLicenseAcceptance&gt; &lt;description&gt;copy so files to build output path&lt;/description&gt; &lt;copyright&gt;Copyright © ilip 2020&lt;/copyright&gt; &lt;tags&gt;linux&lt;/tags&gt; &lt;projectUrl&gt;http://ilip.github.io/&lt;/projectUrl&gt; &lt;/metadata&gt; &lt;files&gt; &lt;file src=&quot;copysofiles.targets&quot; target=&quot;build&quot; /&gt; &lt;file src=&quot;..\\x64\\Release\\*.so&quot; target=&quot;linux&quot; /&gt;&lt;/files&gt;&lt;/package&gt; 运行命令nuget pack ./copysofiles.nuspc -Version 0.0.1 小结以上nuget pack方式，可以打包任意内容到nuget中，进而被工程引用。 .net工程快速生成nuget包1234567891011&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt; &lt;PropertyGroup&gt; &lt;TargetFramework&gt;netstandard2.0&lt;/TargetFramework&gt; &lt;PackageId&gt;dotnetnugettest&lt;/PackageId&gt; &lt;Version&gt;0.0.1&lt;/Version&gt; &lt;Authors&gt;Ace&lt;/Authors&gt; &lt;Company&gt;ilip&lt;/Company&gt; &lt;PackageTags&gt;test,dotnet&lt;/PackageTags&gt; &lt;Description&gt;pack dot net project to nuget&lt;/Description&gt; &lt;/PropertyGroup&gt;&lt;/Project&gt; 运行命令dotnet pack ./dotnetnugettest.csproj","link":"/2020/08/17/nuget-pack-everything/"},{"title":"服务进程无法访问网络资源分析","text":"背景最近遇到一个问题，Local System账号启动的Windows 服务在访问网络资源时，提示没有访问权限。但是使用登陆账号访问时，是可以打开的。这不禁让我内心一紧，赶紧骑上我的小摩托，出去逛一逛。 系统内置账号LocalSystem账户LocalSystem是预设的拥有本机所有权限的本地账户，这个账户跟通常的用户账户没有任何关联，也没有用户名和密码之类的凭证。这个服务账户可以打开注册表的HKEY_LOCAL_MACHINE\\Security键，当LocalSystem访问网络资源时，它是作为计算机的域账户使用的。 Network Service账户Network Service账户是预设的拥有本机部分权限的本地账户，它能够以计算机的名义访问网络资源。但是他没有Local System那么多的权限，以这个账户运行的服务会根据实际环境把访问凭据提交给远程的计算机。Network Service账户通常可以访问Network Service、Everyone组，还有认证用户有权限访问的资源。 Local Service 账户Local Service账户是预设的拥有最小权限的本地账户，并在网络凭证中具有匿名的身份。Local Service账户通常可以访问Local Service、Everyone组还有认证用户有权限访问的资源。 原因分析当用户登录系统时，windows将验证他的密码，如果用户验证成功，系统产生一个访问令牌，它包含用户安全标示符(SID)、组SID列表、特权列表和模拟(Impersonating)信息等安全信息。该用户启动的任何进程都将附加该令牌，访问令牌代表进程的安全环境，它控制了进程与可保护对象(securable object)的交互。当进程访问一个可保护对象时，系统将该对象的访问控制列表(ACL)中的每个访问控制项(ACE)和访问令牌中的 SID 进行比较以确定进程是否可以访问该对象。由于用户启动的任何进程都将附加该用户的访问令牌，因此任何进程都知道用户的 SID 并且可以访问它。Local System 账号是内置的系统账号，所有系统进程都在 Local System 的安全环境中运行，Local System 账号是用于启动服务的默认账号，它继承了服务控制管理器的安全环境，在本地计算机上拥有几乎无限的权限。在 Local System 账号环境运行的进程没有与任何已登录的用户账号相联系，没有用于验证的信任凭证（用户名、域和密码），而该信任凭证(credential)用于网络上其他计算机的验证，这样以 Local System 账号运行的进程就不能访问网络资源，如网络共享。 解决方案整体思路是这样的：到系统的凭据管理中心，添加一个访问网络资源的凭据，然后将local system启动的服务改为当前用户启动，具体操作步骤如下： 添加凭据 切换服务启动用户 输入当前用户名和密码 重启服务","link":"/2019/10/11/servie-with-loaclsystem-account-cannot-access-network-resource/"},{"title":"代码层面解决，服务进程无法访问网络资源","text":"背景上一篇文章 主要介绍了 loacalsystem 无法访问网络资源的原因，同时给出了通过修改启动账号解决问题的方案。当是事情的进展总是没有想的那么顺利，由于公司架构方案的原因，service 必须以localsystem 身份启动，于是开启了下面的旅程。 曙光经过不断的调研和搜索，最终确认了一个分案- Impersonating 简介模拟 Windows Communication Foundation （WCF）服务上的客户端使服务能够代表客户端执行操作。 对于受访问控制列表 (ACL) 检查的操作（例如，访问计算机上的目录和文件，或访问 SQL Server 数据库），ACL 检查针对的是客户端用户帐户。 代码solution整体结构如下图： Service 端关键代码在创建服务接口的实现时，将 OperationBehaviorAttribute 类应用于要求客户端模拟的方法。 将 Impersonation 属性设置为 Required。 12345[OperationBehavior(Impersonation=ImpersonationOption.Required)]public double Add(double a, double b){ return a + b;} Client 端关键代码创建 WCF 客户端之后，将 WindowsClientCredential 类的 AllowedImpersonationLevel 属性设置为 TokenImpersonationLevel 枚举值之一。 123MyWcfService.CalculatorServiceClient client = new MyWcfService.CalculatorServiceClient();client.ClientCredentials.Windows.AllowedImpersonationLevel = TokenImpersonationLevel.Impersonation;Console.WriteLine(&quot;x + y = {2} when x = {0} and y = {1}&quot;, 1, 2, client.Add(1, 2)); 结束很简单的设置，问题就得到解决，如此看来，有时解决问题的方向正确，可以省却许多麻烦的事情。","link":"/2019/10/30/solve-localsystem-account-cannot-access-network-resource-using-code/"},{"title":"以localsystem身份启动应用程序","text":"背景最近处理了许多localsystem 账号相关问题，今天带来的是，在方案验证过程中， 如何以localsystem 身份启动程序。 方法解决这个问题很简单，直接祭出运行工具。 PSTools下载地址直接点我 运行命令先以管理员方式运行cmd。然后运行以下命令： 1C:\\WorkSpace\\tools\\PSTools\\psexec.exe -sid C:\\WorkSpace\\Git\\demo\\WcfServices\\Hosting\\bin\\Release\\Hosting.exe 效果如下图：","link":"/2019/10/20/start-application-through-localsystem-account/"},{"title":"Visual studio 2017 solution (*.sln) CICD with jenkins","text":"Solution build environmentdotnetInstall Path SDK 2.1.507Run Command:dotnet restore SpotPlacementService.sln Build Tools for VS2017Install PathRun Commnad:MSBuild SpotPlacementService.sln /p:configuration=Release /p:Platform=x64 /t:Build Static code analysisCppCheck (cpp)jenkins usageproject siteCppcheck is a static analysis tool for C/C++ code. It provides unique code analysis to detect bugs and focuses on detecting undefined behaviour and dangerous coding constructs. The goal is to detect only real errors in the code (i.e. have very few false positives).Run Commnad:cppcheck --enable=all --inconclusive --xml --xml-version=2 [solution path] 2&gt; cppcheck.xml Cpplint (cpp)project site 1project site 2Cpplint is a command-line tool to check C/C++ files for style issues following Google’s C++ style guide. Cpplint is developed and maintained by Google Inc. at google/styleguide, also see see the wikipedia entryRun Command:lintfordir.py 1234567891011121314151617181920212223242526import osimport fnmatchimport sysdef all_files(root, patterns = '*', single_level = False, yield_folders = False): patterns = patterns.split(';') for path, subdirs, files in os.walk(root): if yield_folders: files.extend(subdirs) files.sort() for name in files: for pattern in patterns: if fnmatch.fnmatch(name, pattern): yield os.path.join(path, name) break if single_level: breakif __name__ == '__main__': if len(sys.argv) &lt; 2: print 'Please set the absolute path as the first parameter for parse.' sys.exit() cmd = &quot;cpplint&quot; for path in all_files(sys.argv[1], '*.cpp;'): cmd = ' '.join([cmd, path]) os.system(cmd) 12lintfordir.py [solution path]set errorlevel=0 FxCop (C#)jenkins usageproject siteFxCopCmd analyzes managed code assemblies and reports information about the assemblies, such as possible design, localization, performance, and security improvements. stylecop (C#)project sitemaybe usageIntegrates source code analysis into the build process of C# projects to enforce a set of style and consistency rules..NETCLI install methoddotnet add package StyleCop.MSBuild --version 6.1.0 usage Unit TestMStest (C#)usage Cppunit (C++)usageCppUnit is the C++ port of the famous JUnit framework for unit testing.Test output is in XML or text format for automatic testing and GUI based for supervised tests. Google Test (C++)project siteusage Display UT ResultxUnitThis plugin makes it possible to publish the test results of an execution of a testing tool in Jenkins. Cyclomatic complexitySourceMonitor (C#, C++)usage Jenkins usagePlugin InstallationCppcheck FxCop Runner Violations CCM","link":"/2019/09/17/visual-studio-solution-CICD-with-jenkins/"},{"title":"VS 高效使用技巧","text":"背景平时用到的一些VS高效、批量操作 VS 正则表达式，替换匹配项部分内容查找 JjrxtAccess 替换其中 Jjrxt --&gt; Jydc 查找内容写 (Jjrxt)([a-z,A-Z]*) 替换内容写 Jydc$2 $0,其中$0表示正则匹配的整个最大字符串值。 $1,表示在查找的表达式中查找到的第一个（）指定的字符。 $2,表示在查找的表达式中查找到的第二个（）指定的字符。 … $n,表示在查找的表达式中查找到的第n个（）指定的字符。 Windows 通配符批量重命名必须使用cmd窗口来操作 不能用regex来做，但可以用rename通配符来做。 ren &quot;t1-??-?? t2-??-??.txt&quot; &quot;???00-99*&quot; 在目标掩码中，每个?保留一个字符，文本执行一对一字符替换，*保留其余字符。 Linux rename command 正则表达式批量重命名follow this rename &quot;s/AA/aa/&quot; * # 把文件名中的AA替换成aa VS code, 为写出的变量引入 import 头声明选中变量/声明， Ctrl + . 快捷键，提示导入import 头","link":"/2020/10/17/vs-efficiency/"},{"title":"Converter visual studio solution to linux platform","text":"Converter VS Sln to cmake filesClick me to get the tool Usage: cmake-converter -s [solution file path] VS2019 open cmake folderCmake overviewFollow the CMake Overview window tips to finish WSL install. If you can’t see the window, open it by yourself through [your sln folder]\\.vs\\CMake Overview Target linuxClick Target Linux tab on the left of CMake Overview window Install the Linux development with C++ workloadConnect to the windows subsystem for LinuxInstall WSL and initialize your new distro Install WSL required dependencyRun the command on the WSL sudo apt-get install openssh-server g++ gdb make rsync zip Add a WSL configuration Click Open your existing configuration Click + button to add a new configuration select WSL-Debug on the pop up window change Path to WSL(Windows Subsystem for linux) executable: path to your installed WSL path Click Save all button Select WSL-Debug configuration on the side of Run button now we can use the linux platform to build CMake folder vcpkgvcpkg: a C++ package manager for Windows, Linux, and MacOS Installation123git clone https://github.com/Microsoft/vcpkgcd vcpkg.\\bootstrap-vcpkg.bat Install package for projectEnter vcpkg folder then execute the command 1vcpkg install rapidjson:x64-windows 1vcpkg install rapidjson:x64-windows --overlay-ports=./vcpkg-ports/v1 After running the command, it will respond some code, please copy the code. 12find_package(RapidJSON CONFIG REQUIRED)target_include_directories(main PRIVATE ${RAPIDJSON_INCLUDE_DIRS}) Enter the solution folder, modify the CMakeLists.txt like this 1234cmake_minimum_required(VERSION 3.13.0 FATAL_ERROR)set(CMAKE_TOOLCHAIN_FILE &quot;C:/Workspace/git/vcpkg/scripts/buildsystems/vcpkg.cmake&quot;)project(OptimizationLibrary CXX)... Open project CMakeLists.txt file, then append the code you copied and modify some field, it will look like this 123find_package(RapidJSON CONFIG REQUIRED)target_include_directories(${PROJECT_NAME} PRIVATE ${RAPIDJSON_INCLUDE_DIRS}) vcpkg export and importvcpkg export 12345678910C:\\vcpkg&gt;vcpkg export gtest:x64-windows --nugetThe following packages are already built and will be exported: gtest:x64-windowsExporting package gtest:x64-windows...Packing nuget package...NuGet package exported at: C:\\vcpkg\\vcpkg-export-20200731-165202.1.0.0.nupkgWith a project open, go to Tools-&gt;NuGet Package Manager-&gt;Package Manager Console and paste: Install-Package vcpkg-export-20200731-165202 -Source &quot;C:\\vcpkg&quot; 1Install-Package vcpkg-export-20200731-165202 -Source &quot;C:\\workspace\\git\\DoseService\\PBDoseEngine&quot; A CMake toolchain file is included when exporting from vcpkg export. It is in scripts\\buildsystems. To use it, you need to specify the CMAKE_TOOLCHAIN_FILE variable when calling CMake: 1&gt; cmake .. &quot;-DCMAKE_TOOLCHAIN_FILE=E:/workspace/vcpkg/vcpkg-export-20170502-161923/scripts/buildsystems/vcpkg.cmake&quot;","link":"/2020/08/21/vs-sln-2-linux/"},{"title":"windows 使用中遇到的问题","text":"背景平时windows使用过程中遇到的一些问题总结 How to use a new Windows Terminal app for SSH参考这里 Add-WindowsCapability failed. Error code = 0x800f09501gpedit.msc (Group Policy) -&gt; Computer Configuration -&gt; Admin. Templates -&gt; Windows Components -&gt; Windows Update -&gt; Specify intranet Microsoft update service location -&gt; Disabled 具体请参考这里","link":"/2020/11/20/windows-usage-issues/"},{"title":"WPF 开发中遇到的问题","text":"背景平时WPF开发过程中遇到的一些问题总结 EF 6 for .net framework DB firstUse MySQL Installer to install all the needed develop environment Below show all the needed components: (Make sure all the components in same version) 12345mySql routerConnector/ODBCConnector/C++Connector/NetMySQl Server Get Nuget package mysql.data.entityFramework using the same version as above. Right click your project &gt; Add new Item &gt; Data (left navbar) &gt; Ado.net entity Data Model new a project that hold the entity framework DbContext and all relative nuget dependency. then the application project just reference the database project, but in the app.config file, should add the following settings 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;configuration&gt; &lt;configSections&gt; &lt;!-- For more information on Entity Framework configuration, visit http://go.microsoft.com/fwlink/?LinkID=237468 --&gt; &lt;section name=&quot;entityFramework&quot; type=&quot;System.Data.Entity.Internal.ConfigFile.EntityFrameworkSection, EntityFramework, Version=6.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089&quot; requirePermission=&quot;false&quot; /&gt; &lt;/configSections&gt; &lt;entityFramework&gt; &lt;providers&gt; &lt;provider invariantName=&quot;System.Data.SqlClient&quot; type=&quot;System.Data.Entity.SqlServer.SqlProviderServices, EntityFramework.SqlServer&quot; /&gt; &lt;provider invariantName=&quot;MySql.Data.MySqlClient&quot; type=&quot;MySql.Data.MySqlClient.MySqlProviderServices, MySql.Data.EntityFramework, Version=8.0.22.0, Culture=neutral, PublicKeyToken=c5687fc88969c44d&quot;&gt;&lt;/provider&gt; &lt;/providers&gt; &lt;/entityFramework&gt; &lt;connectionStrings&gt; &lt;add name=&quot;EFDbContext&quot; connectionString=&quot;server=localhost;user id=root;password=123456xu;database=erp;persistsecurityinfo=True&quot; providerName=&quot;MySql.Data.MySqlClient&quot; /&gt; &lt;/connectionStrings&gt;&lt;/configuration&gt; Also shoul set the database project build outpath to the application project","link":"/2020/11/22/wpf-development/"}],"tags":[{"name":"Angular","slug":"Angular","link":"/tags/Angular/"},{"name":"angular","slug":"angular","link":"/tags/angular/"},{"name":"cicd","slug":"cicd","link":"/tags/cicd/"},{"name":"azure app service","slug":"azure-app-service","link":"/tags/azure-app-service/"},{"name":".net","slug":"net","link":"/tags/net/"},{"name":"azure","slug":"azure","link":"/tags/azure/"},{"name":"pipeline","slug":"pipeline","link":"/tags/pipeline/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"crossplateform","slug":"crossplateform","link":"/tags/crossplateform/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"往事","slug":"往事","link":"/tags/%E5%BE%80%E4%BA%8B/"},{"name":"asp.net","slug":"asp-net","link":"/tags/asp-net/"},{"name":"identityserver4","slug":"identityserver4","link":"/tags/identityserver4/"},{"name":"nginx","slug":"nginx","link":"/tags/nginx/"},{"name":"https","slug":"https","link":"/tags/https/"},{"name":"windows","slug":"windows","link":"/tags/windows/"},{"name":"cpp","slug":"cpp","link":"/tags/cpp/"},{"name":"markdown","slug":"markdown","link":"/tags/markdown/"},{"name":"nuget","slug":"nuget","link":"/tags/nuget/"},{"name":"package","slug":"package","link":"/tags/package/"},{"name":"localsystem","slug":"localsystem","link":"/tags/localsystem/"},{"name":"service","slug":"service","link":"/tags/service/"},{"name":"PSTools","slug":"PSTools","link":"/tags/PSTools/"},{"name":"vs2017","slug":"vs2017","link":"/tags/vs2017/"},{"name":"jenkins","slug":"jenkins","link":"/tags/jenkins/"},{"name":"vs","slug":"vs","link":"/tags/vs/"},{"name":"efficiency","slug":"efficiency","link":"/tags/efficiency/"},{"name":"Cmake","slug":"Cmake","link":"/tags/Cmake/"},{"name":"issue","slug":"issue","link":"/tags/issue/"},{"name":"wpf","slug":"wpf","link":"/tags/wpf/"}],"categories":[{"name":"探索中前进","slug":"探索中前进","link":"/categories/%E6%8E%A2%E7%B4%A2%E4%B8%AD%E5%89%8D%E8%BF%9B/"},{"name":"往事","slug":"往事","link":"/categories/%E5%BE%80%E4%BA%8B/"}]}